import json
from openai import OpenAI
import os
import sqlite3
from time import time
from datetime import datetime

print("Running db_bot.py!")

fdir = os.path.dirname(__file__)
def getPath(fname):
    return os.path.join(fdir, fname)

# SQLITE
sqliteDbPath = getPath("aidb.sqlite")
setupSqlPath = getPath("setup.sql")
setupSqlDataPath = getPath("setupData.sql")

# Erase previous db
if os.path.exists(sqliteDbPath):
    os.remove(sqliteDbPath)

sqliteCon = sqlite3.connect(sqliteDbPath) # create new db
sqliteCursor = sqliteCon.cursor()
with (
        open(setupSqlPath) as setupSqlFile,
        open(setupSqlDataPath) as setupSqlDataFile
    ):

    setupSQLScript = setupSqlFile.read()
    setupSQLDataScript = setupSqlDataFile.read()

sqliteCursor.executescript(setupSQLScript) # setup tables and keys
sqliteCursor.executescript(setupSQLDataScript) # setup tables and keys

def runSql(query):
    result = sqliteCursor.execute(query).fetchall()
    return result

# OPENAI
configPath = getPath("openai_api_token.json")
print(configPath)
with open(configPath) as configFile:
    config = json.load(configFile)

openAiClient = OpenAI(api_key = config["openaiKey"])

def getChatGptResponse(content):
    stream = openAiClient.chat.completions.create(
        model="gpt-4o",
        messages=[{"role": "user", "content": content}],
        stream=True,
    )

    responseList = []
    for chunk in stream:
        if chunk.choices[0].delta.content is not None:
            responseList.append(chunk.choices[0].delta.content)

    result = "".join(responseList)
    return result


# strategies
commonSqlOnlyRequest = " Give me a sqlite select statement that answers the following question. Only respond with sqlite syntax. If there is an error do not explain it!"
strategies = {
    "zero_shot": setupSQLScript + commonSqlOnlyRequest,
    "single_domain_double_shot": (setupSQLScript +
                   "Example Question: Which employees have the highest commission rates? " +
                   "Example Response based off schema: \nSELECT e.firstName, e.lastName, cr.commissionRate\nFROM Employee e\nJOIN CommissionRate cr ON e.commissionID = cr.ID\nORDER BY cr.commissionRate DESC;\n " +
                   commonSqlOnlyRequest)
}

questions = [
    "What is a cold caller's lead conversion per hour ratio?",
    "How much total revenue has been generated by bound leads in the last year?",
    "Who was the agent and the cold caller that worked the highest bound lead in the last 5 years?",
    "How long has each employee worked at the brokerage?",
    "Which office has the highest average commission rate among its employees?",
    "What is the success rate of leads found by cold callers versus outside sales reps?",
    "How many employees work at each office?",
    "How many leads has each employee worked on?",
    "Which employees have the highest commission rates?"
]

def sanitizeForJustSql(value):
    gptStartSqlMarker = "```sql"
    gptEndSqlMarker = "```"
    
    # First try to extract SQL from code blocks
    if gptStartSqlMarker in value:
        parts = value.split(gptStartSqlMarker)
        if len(parts) > 1:
            value = parts[1]
            if gptEndSqlMarker in value:
                value = value.split(gptEndSqlMarker)[0]
    
    # Clean up any remaining whitespace
    value = value.strip()
    
    # If the response starts with "sqlite" or similar, remove it
    if value.lower().startswith(('sqlite', 'ite')):
        value = value.split(' ', 1)[1] if ' ' in value else ''
    
    # Ensure we have a complete SQL statement
    value = value.strip()
    if not value.lower().startswith('select'):
        # If we have a FROM clause but no SELECT, try to reconstruct the query
        if 'from' in value.lower():
            parts = value.split('from', 1)
            if len(parts) > 1:
                columns = parts[0].strip()
                from_part = parts[1].strip()
                value = f"SELECT {columns} FROM {from_part}"
    
    return value.strip()

for strategy in strategies:
    responses = {"strategy": strategy, "prompt_prefix": strategies[strategy]}
    questionResults = []
    for question in questions:
        print(question)
        error = "None"
        sqlSyntaxResponse = ""
        queryRawResponse = ""
        friendlyResponse = ""
        try:
            getSqlFromQuestionEngineeredPrompt = strategies[strategy] + " " + question
            sqlSyntaxResponse = getChatGptResponse(getSqlFromQuestionEngineeredPrompt)
            sqlSyntaxResponse = sanitizeForJustSql(sqlSyntaxResponse)
            print(sqlSyntaxResponse)
            queryRawResponse = str(runSql(sqlSyntaxResponse))
            print(queryRawResponse)
            betterFriendlyResultsPrompt = "I asked a question: \"" + question +"\" and I queried this database " + setupSQLScript + " with this query " + sqlSyntaxResponse + ". The query returned the results data: \""+queryRawResponse+"\". Could you concisely answer my question using the results data, but describe any person entity by its name instead of ID?"
            friendlyResponse = getChatGptResponse(betterFriendlyResultsPrompt)
            print(friendlyResponse)
        except Exception as err:
            error = str(err)
            print(err)

        questionResults.append({
            "question": question,
            "sql": sqlSyntaxResponse,
            "queryRawResponse": queryRawResponse,
            "friendlyResponse": friendlyResponse,
            "error": error
        })

    responses["questionResults"] = questionResults

    # Format datetime for filename
    current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
    with open(getPath(f"strategy_{strategy}_{current_time}.json"), "w") as outFile:
        json.dump(responses, outFile, indent = 2)


sqliteCursor.close()
sqliteCon.close()
print("Done!")
